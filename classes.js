// Generated by CoffeeScript 1.11.1
(function() {
  var HandlerModules, allClasses, findPerson, flushJSON, fs, getIndexedClassFromPerson, getSharedClasses, http, j, k, len, len1, m, markForDeletion, person, ref, serv, tempList, url,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  http = require('http');

  url = require('url');

  allClasses = JSON.parse(fs.readFileSync("/projects/classes.json"));

  console.log("Resolving double entries");

  tempList = [];

  markForDeletion = [];

  for (j = 0, len = allClasses.length; j < len; j++) {
    person = allClasses[j];
    if (ref = person.name, indexOf.call(tempList, ref) >= 0) {
      markForDeletion.push(person);
      console.log("DoubleEntryFind: " + person + " has multiple entries");
    } else {
      tempList.push(person.name);
    }
  }

  console.log("DoubleEntryFind: " + markForDeletion + " marked for deletion");

  for (k = 0, len1 = markForDeletion.length; k < len1; k++) {
    m = markForDeletion[k];
    allClasses.pop(m);
  }

  console.log("DoubleEntryFind: deleted double entries");

  findPerson = function(name) {
    var c, l, len2;
    for (l = 0, len2 = allClasses.length; l < len2; l++) {
      c = allClasses[l];
      if (c.name === name) {
        return c;
      }
    }
  };

  getIndexedClassFromPerson = function(name, index) {
    if (!findPerson(name)) {
      return false;
    }
    return (findPerson(name)).classes[index];
  };

  getSharedClasses = function(name, other) {
    var i, otherClasses, output, thisClasses;
    if (!findPerson(name || !findPerson(other))) {
      console.warn("getSharedClasses encountered name:" + name + ", other:" + other + ", some unknown");
      return false;
    } else {
      output = "";
      thisClasses = (findPerson(name)).classes;
      otherClasses = (findPerson(other)).classes;
      i = 0;
      while (i < 7) {
        if (thisClasses[i] === otherClasses[i]) {
          output += "Period " + (i + 1) + ": " + (getIndexedClassFromPerson(name, i)) + "\n";
        }
        i++;
      }
      return output;
    }
  };

  flushJSON = function() {
    return fs.writeFile("/projects/classes.json", JSON.stringify(allClasses));
  };

  HandlerModules = {
    NewSchedule: {
      RequiredParams: function() {
        var buf, i;
        buf = ["name"];
        i = 0;
        while (i < 7) {
          buf.push("classes" + i);
          i++;
        }
        return buf;
      },
      Handle: function(query, resp) {
        var a, qclasses;
        if (findPerson(query.name)) {
          return resp.end("That person already exists");
        } else {
          qclasses = [];
          a = 0;
          while (a < 7) {
            qclasses.push(query["classes" + a]);
            a++;
          }
          if (qclasses.length !== 7) {
            console.error("Invalid qclasses! " + qclasses);
          }
          allClasses.push({
            name: query.name,
            classes: qclasses
          });
          flushJSON();
          console.log("New record for " + query.name);
          return resp.end("Schedule inserted successfully");
        }
      }
    },
    EditSchedule: {
      RequiredParams: function() {
        return ["name", "classIndex", "newClass"];
      },
      Handle: function(query, resp) {
        var classIndex, l, len2, user;
        if (!findPerson(query.name)) {
          resp.end("Person named " + query.name + " does not exist");
          return;
        }
        classIndex = parseInt(query.classIndex);
        if (classIndex === (0/0)) {
          resp.end("classIndex (" + query.classIndex + ") not an integer");
          return;
        }
        if (classIndex < 0 || classIndex > 6) {
          resp.end("classIndex " + classIndex + " out of range");
          return;
        }
        for (l = 0, len2 = allClasses.length; l < len2; l++) {
          user = allClasses[l];
          if (user.name === query.name) {
            user.classes[classIndex] = query.newClass;
            flushJSON();
            resp.end("Classes have been updated. New classes: " + user.classes);
            return;
          }
        }
        return resp.end("The server has an issue. Report to the owner.");
      }
    },
    GetShared: {
      RequiredParams: function() {
        return ["name1", "name2"];
      },
      Handle: function(query, resp) {
        var sharedClasses;
        sharedClasses = getSharedClasses(query.name1, query.name2);
        if (sharedClasses === false) {
          return resp.end("Failed to find shared classes. The most likely issue is mistaken person names.");
        } else {
          return resp.end(query.name1 + " and " + query.name2 + " share --\n" + sharedClasses);
        }
      }
    },
    ListUsers: {
      RequiredParams: function() {
        return [];
      },
      Handle: function(query, resp) {
        var buffer, l, len2;
        buffer = "List of users with recorded schedule --\n";
        for (l = 0, len2 = allClasses.length; l < len2; l++) {
          person = allClasses[l];
          buffer += " - " + person.name + "\n";
        }
        return resp.end(buffer);
      }
    },
    GetSummary: {
      RequiredParams: function() {
        return ["name"];
      },
      Handle: function(query, resp) {
        var buffer, l, len2;
        if (!findPerson(query.name)) {
          return resp.end(query.name + " does not exist");
        } else {
          buffer = "Summary of shared classes, freshly generated for " + query.name + "\n-----\n";
          for (l = 0, len2 = allClasses.length; l < len2; l++) {
            person = allClasses[l];
            if (person.name !== query.name) {
              buffer += "with " + person.name + ": \n" + (getSharedClasses(query.name, person.name)) + "-----\n";
            }
          }
          return resp.end(buffer);
        }
      }
    },
    GetAlternativeSummary: {
      RequiredParams: function() {
        return ["name"];
      },
      Handle: function(query, resp) {
        var buffer, i, l, len2, perso;
        if (!findPerson(query.name)) {
          return resp.end("That person cannot be found: " + query.name);
        } else {
          buffer = "Classmates of " + query.name + " per period --\n-----\n";
          perso = findPerson(query.name);
          i = 0;
          while (i < 7) {
            buffer += "Period " + (i + 1) + " (" + perso.classes[i] + ") classmates:\n";
            for (l = 0, len2 = allClasses.length; l < len2; l++) {
              person = allClasses[l];
              if (person.classes[i] === perso.classes[i] && person.name !== perso.name) {
                buffer += " - " + person.name + "\n";
              }
            }
            buffer += "-----\n";
            i++;
          }
          return resp.end(buffer);
        }
      }
    }
  };

  serv = http.createServer(function(request, response) {
    var l, len2, query, ref1, ref2, rp;
    query = (url.parse(request.url, true)).query;
    console.log("New request: " + request.url);
    if (!query.type || (ref1 = query.type, indexOf.call(Object.keys(HandlerModules), ref1) < 0)) {
      return response.end("Bad type");
    } else {
      ref2 = HandlerModules[query.type].RequiredParams();
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        rp = ref2[l];
        if (indexOf.call(Object.keys(query), rp) < 0) {
          response.end("Missing required parameter for module " + query.type + ": " + rp);
          return;
        }
      }
      return HandlerModules[query.type].Handle(query, response);
    }
  });

  serv.listen(8081);

}).call(this);
